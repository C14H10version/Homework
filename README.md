# Homework
1.选择排序法
思想：先把最小的拿出来，再从剩下的中把最小的拿出来，一直从剩下的中把最小的拿出来······即每一次都选择还没处理的数据元素中最小的。
1.1原地排序思想
把剩下的元素中找到的最小的元素放在数组开头的位置

设置索引i和j，索引i初始时指着索引0的位置表示排序之后数组中第0个元素，为了寻找最小的元素j从i的位置出发到最后一个元素扫描一遍元素。用minIndex记录找到的最小的元素的位置（如上图中1的位置为4）。

将1和6交换位置，如上图交换完位置后i=0的位置处的元素就是排序后最小元素，接下来处理i=1处元素（i++）。这个处理过程中数组arr[i,n)是为排序的。我们的处理过程就是从arr[i，n）中找到最小的元素和arr[i]位置的元素进行交换。
原地选择排序Java实现：

1.2使用带约束的泛型：
1.将int改成<E>后报错因为E这种类型未必可以使用<进行比较，所以不能简单使用E这个泛型，需要对其做一个约束。
2.带约束的泛型语法 <Eextends Comparable<E>>
3.Comparable接口使用的比较方法使用compareTo方法，compareTo返回一个整型参数，arr.[j].compareTo(arr[minIndex])该参数>0表示前者大于后者,该参数=0表示前者等于后者，该参数<0表示前者小于后者。
4.SelectionSort.sort(arr)报错，因为arr现在接受的是一个泛型数组，而泛型要求的是一个类而不是基本数据类型，所以将int arr={1,4,2,3,9,8,6,5};改成Integer arr={1,4,2,3,9,8,6,5};。
5.修改后的代码可以对任意类型数组进行排序，但是该数组必须是可比较的（约束）。

1.3使用自定义的student类测试这种带约束的泛型方法（comparable接口）：
1.equals比较类对象。
2.欲令student类可以进行比较必须对其实现comparable接口。
3.public int ComoparableTo(student another){} 逻辑→当前的类和传来的类进行比较，当前类更小则返回负数，反之返回正数，相等则返回0。
4.toString方法打印student类如下图

5.欲令之从大到小排序则public int ComoparableTo(student another){return this.score-another.score;}改成
   public int ComoparableTo(student another){return another.score-this.score;} 
1.4选择排序法的算法复杂度分析：

如上图该算法有两重循环，显然第一重循环运行了n次。
对于第二重循环：当i=0，运行了n次；当i=1，运行了n-1次；···；当i=n-1，运行了1次。所以总的运行次数为1+2+3+···+n=(n+1)n/2=1/2 n^2+1/2 n
所以算法的时间复杂度为:0(n^2 )
1.5算法性能测试
1.数组生成器ArrayGenerator，如下图


2.实际测试中设置n和bound为一万。
3.对运行时间进行计时endTime-startTime。

4.验证排序结果，扫描每两个元素看是否满足前一个小于后一个，方法封装成sortingHelper类。

5.为了比较插入排序和选择排序的性能，在sortingHelper中使用sortTest函数测试排序算法（选择or插入），参数为算法名和泛型数组。

1.6换个角度实现选择排序（从小到大）：
arr[i,n)未排序，arr[0,i)已排序
实现逻辑：从后向前扫描，对于每一个i，arr[i]和arr[maxindex]交换位置即可


2.插入排序法
2.1思想：
每次处理一个元素，把这个元素插入到前面已排序好的的数组中，如下图。

1.arr[0,i)已排好序， arr[i···n)未排序，将arr[i]放到合适的位置。
2.索引i从0开始到n指引每次要处理的元素，i=0处理第一个元素，···，i=n处理最后一个元素。
3.处理方法即为将元素插入到合适的位置，这个合适的位置通过不断比较元素和它前一个位置的元素大小确定。
4.设置索引j寻找合适的位置，初始j=i,一步一步向前看，如果j位置元素小于前一个元素，则二者进行交换。
5.比较j和j-1位置的元素进行排序，j跟着元素动如下图，此时4已经是第一个元素不用与j-1个元素进行比较，元素4完成处理。

2.2代码实现：

1.时间测试中通过sortname判断排序类型

2.SortingHelper中sortTest方法在对排序算法进行判断的时候也对排序结果的正确性进行了验证
2.3排序算法的优化：
1.将一排好序的数进行平移的过程通过一次赋值完成，简化原来的每次交换需要3次排序。
2.先使用一个变量暂存需要处理的元素，如图中元素3，比较3和前面的6,6更大则让arr[j]直接等于6，即6向后平移一个位置，然后j--

 
3.对j位置的元素和前面一个元素进行比较，前面的更大则继续平移。
4.当j-1位置的元素比3小的时候，3插入到j位置。
5.时间复杂度不变仍然是0(n^2 )。

2.4插入排序法的重要特性
1.对于有序数组，时间复杂度是O(n)，当然整体来说其时间复杂度还是0(n^2 )。
2.对比，选择排序法时间复杂度永远是0(n^2 )。
2.5换个方法实现插入排序
将循环不变量换过来


1.基本逻辑是从后向前扫描，对于每一个 arr[i]，寻找 arr[i...n) 区间中需要插入的位置。
2.在具体找这个位置的时候， 我们依然是暂存 arr[i] 到 t 这个变量。
3.之后，只要 t 比当前的 arr[j + 1] 还要大，说明 t 应该插入的位置还靠后，我们只需要让 arr[j + 1] 平行移动到 arr[j] 的位置，然后 j ++，继续看下一个 j。

归并排序算法的时间复杂度
O(n log⁡n )
分析：以arr[0···7]为例，对其进行归并排序需要对其分解，共分解logn层，每层分解需要遍历一般整个数组，每次遍历是O（n）。这个过程是一个递归树。

在有序数组，让归并排序成为O（n）算法

如果merge不执行，每一层就不需要遍历，每一层的操作都是常数级别的，也就是说对merg进行判断后，完全有序的数组是O(n)。
![image](https://user-images.githubusercontent.com/96689647/184541504-26f09f5f-b971-4d53-85ee-19153105cd28.png)
